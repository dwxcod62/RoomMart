window.FrontEnd || (window.FrontEnd = {});
FrontEnd.MarkingProductsServices = function() {
    function i() {
        return new Promise(n => {
            waitObject("userServices").then(() => window.userServices.getCurrentUserInfo()).then(t => {
                if (t) {
                    var i = cacheHelper.get(r);
                    if (i && i.length || (i = []), window.FrontEnd.MarkingProductsServices_isSynedMarkedProduct) {
                        waitObject("FrontEnd.MarkingProductsServices_MarkedProducts").then(() => {
                            n(window.FrontEnd.MarkingProductsServices_MarkedProducts.sort(function(n, t) {
                                return new Date(t.saveTime) - new Date(n.saveTime)
                            }))
                        });
                        return
                    }
                    window.FrontEnd.MarkingProductsServices_isSynedMarkedProduct = !0;
                    o(i).then(t => {
                        window.FrontEnd.MarkingProductsServices_MarkedProducts = t, cacheHelper.remove(r), n(window.FrontEnd.MarkingProductsServices_MarkedProducts.sort(function(n, t) {
                            return new Date(t.saveTime) - new Date(n.saveTime)
                        }))
                    })
                } else waitObject("cacheHelper").then(() => {
                    var t = cacheHelper.get(r);
                    if (t) {
                        n(t.sort(function(n, t) {
                            return new Date(t.saveTime) - new Date(n.saveTime)
                        }));
                        return
                    }
                    n([])
                })
            })
        })
    }

    function o(n) {
        return new Promise(i => {
            waitObject("urlServices").then(window.urlServices.getDomains).then(r => {
                fetch(`${r.msvrouter}${t.syncMarkedProductsUrl}`, {
                    method: "POST",
                    headers: {
                        Accept: "application/json",
                        "Content-Type": "application/json"
                    },
                    body: JSON.stringify({
                        markedProducts: n
                    })
                }).then(n => n.status === 200 && n.json()).then(n => {
                    i(n)
                })
            })
        })
    }

    function s(n) {
        return new Promise(r => {
            waitObject("urlServices").then(window.urlServices.getDomains).then(u => {
                i().then(i => {
                    let f = i.map((n, t) => `documentIds[${t}]=${n.documentId}`).join("&");
                    f += `&sortType=${n}`;
                    fetch(`${u.msvrouter}${t.getCardsByIdsUrl}?${f}`, {
                        method: "GET",
                        headers: {
                            Accept: "application/json",
                            "Content-Type": "application/json"
                        }
                    }).then(n => n.status === 200 && n.json()).then(n => {
                        r(n.map(n => n.html))
                    })
                })
            })
        })
    }

    function h() {
        return new Promise(n => {
            waitObject("urlServices").then(window.urlServices.getDomains).then(r => {
                i().then(i => {
                    var e, o;
                    let f = ``;
                    if (e = 0, i.forEach(n => {
                            var t = cacheHelper.get(`${u}_${n.documentId}`);
                            t || (f.endsWith("&") || (f += "&"), f += `documentIds[${e}]=${n.documentId}`, e++)
                        }), !f) {
                        o = i.map(n => cacheHelper.get(`${u}_${n.documentId}`));
                        n(o.filter(n => n));
                        return
                    }
                    fetch(`${r.msvrouter}${t.getNotificationObjectsUrl}?${f}`, {
                        method: "GET",
                        headers: {
                            Accept: "application/json",
                            "Content-Type": "application/json"
                        }
                    }).then(n => n.status === 200 && n.json()).then(n => {
                        n.forEach(n => {
                            let t = i.find(t => t.documentId == n.documentId);
                            t && (cacheHelper.set(`${u}_${n.documentId}`, n, 1440), n.saveTime = t.saveTime)
                        })
                    }).then(() => {
                        var t = i.map(n => cacheHelper.get(`${u}_${n.documentId}`));
                        n(t.filter(n => n))
                    })
                })
            })
        })
    }

    function f(e) {
        return e && e.avatarinfowap && cacheHelper.set(`${u}_${e.documentId}`, e, 1440), new Promise((u, o) => {
            if (n) {
                setTimeout(() => {
                    f(e).then(u, o)
                }, 100);
                return
            }
            n = !0;
            waitObject("userServices").then(() => window.userServices.getCurrentUserInfo()).then(f => {
                if (f) {
                    if (window.FrontEnd.MarkingProductsServices_MarkedProducts.filter(n => n.documentId == e.documentId).length) {
                        u({
                            marked: !0
                        });
                        return
                    }
                    window.FrontEnd.MarkingProductsServices_MarkedProducts.unshift({
                        documentId: e.documentId,
                        saveTime: (new Date).toUTCString()
                    });
                    window.FrontEnd.MarkingProductsServices_MarkedProducts.length > t.listingLimit && window.FrontEnd.MarkingProductsServices_MarkedProducts.pop();
                    u({
                        marked: !0
                    });
                    waitObject("urlServices").then(window.urlServices.getDomains).then(i => {
                        fetch(`${i.msvrouter}${t.markProductUrl}?documentId=${e.documentId}`, {
                            method: "POST",
                            headers: {
                                Accept: "application/json",
                                "Content-Type": "application/json"
                            }
                        }).then(() => {
                            n = !1
                        }, () => {
                            n = !1
                        })
                    })
                } else i().then(i => {
                    if (i.filter(n => n.documentId == e.documentId).length) {
                        u({
                            marked: !0
                        });
                        return
                    }
                    i.unshift({
                        documentId: e.documentId,
                        saveTime: (new Date).toUTCString()
                    });
                    i.length > t.listingLimit && i.pop();
                    window.cacheHelper.set(r, i, 525600);
                    n = !1;
                    u({
                        marked: !0
                    })
                })
            })
        })
    }

    function e(u) {
        return new Promise((e, o) => {
            if (n) {
                setTimeout(() => {
                    f(markProductParams).then(e, o)
                }, 100);
                return
            }
            n = !0;
            waitObject("userServices").then(() => window.userServices.getCurrentUserInfo()).then(f => {
                if (f) {
                    if (!window.FrontEnd.MarkingProductsServices_MarkedProducts.filter(n => n.documentId == u.documentId).length) {
                        e({
                            marked: !1
                        });
                        return
                    }
                    window.FrontEnd.MarkingProductsServices_MarkedProducts = window.FrontEnd.MarkingProductsServices_MarkedProducts.filter(n => n.documentId != u.documentId);
                    e({
                        marked: !1
                    });
                    waitObject("urlServices").then(window.urlServices.getDomains).then(i => {
                        fetch(`${i.msvrouter}${t.unmarkProductUrl}?documentId=${u.documentId}`, {
                            method: "POST",
                            headers: {
                                Accept: "application/json",
                                "Content-Type": "application/json"
                            }
                        }).then(() => {
                            n = !1
                        }, () => {
                            n = !1
                        })
                    })
                } else i().then(t => {
                    if (!t.filter(n => n.documentId == u.documentId).length) {
                        e({
                            marked: !1
                        });
                        return
                    }
                    t = t.filter(n => n.documentId != u.documentId);
                    window.cacheHelper.set(r, t, 525600);
                    n = !1;
                    e({
                        marked: !1
                    })
                })
            })
        })
    }

    function c(n) {
        return new Promise((t, r) => {
            i().then(i => {
                if (i.filter(t => t.documentId == n.documentId).length) {
                    e(n).then(t).catch(r);
                    return
                }
                f(n).then(t).catch(r);
                return
            })
        })
    }
    var r = "MARKED_PRODUCTS",
        u = "MARKED_PRODUCTS_NOTIFICATION_OBJECT",
        n = !1,
        t = JSON.parse(document.querySelectorAll("script[marking-product-service-params]")[0].getAttribute("marking-product-service-params"));
    this.GetMarkedProducts = i;
    this.GetMarkedProductCardHtmlsInSrp = s;
    this.GetNotificationObjects = h;
    this.MarkProduct = f;
    this.UnmarkProduct = e;
    this.MarkOrUnmarkProduct = c
};
window.libpannellum = function(n, t, i) {
    function u(u) {
        function pt(n, t) {
            return 1 == n.level && 1 != t.level ? -1 : 1 == t.level && 1 != n.level ? 1 : t.timestamp - n.timestamp
        }

        function wt(n, t) {
            return n.level != t.level ? n.level - t.level : n.diff - t.diff
        }

        function nt(n, t, i, r, u, f) {
            this.vertices = n;
            this.side = t;
            this.level = i;
            this.x = r;
            this.y = u;
            this.path = f.replace("%s", t).replace("%l", i).replace("%x", r).replace("%y", u)
        }

        function ht(n, t, i, r, u) {
            var f, o = t.vertices;
            f = tt(n, o.slice(0, 3));
            var e = tt(n, o.slice(3, 6)),
                s = tt(n, o.slice(6, 9)),
                o = tt(n, o.slice(9, 12)),
                h = f[0] + e[0] + s[0] + o[0];
            if (-4 == h || 4 == h ? f = !1 : (h = f[1] + e[1] + s[1] + o[1], f = -4 == h || 4 == h ? !1 : 4 != f[2] + e[2] + s[2] + o[2]), f) {
                for (f = t.vertices, e = f[0] + f[3] + f[6] + f[9], s = f[1] + f[4] + f[7] + f[10], o = f[2] + f[5] + f[8] + f[11], h = Math.sqrt(e * e + s * s + o * o), o = Math.asin(o / h), e = Math.atan2(s, e) - r, e += e > Math.PI ? -2 * Math.PI : e < -Math.PI ? 2 * Math.PI : 0, e = Math.abs(e), t.diff = Math.acos(Math.sin(i) * Math.sin(o) + Math.cos(i) * Math.cos(o) * Math.cos(e)), e = !1, s = 0; s < l.nodeCache.length; s++)
                    if (l.nodeCache[s].path == t.path) {
                        e = !0;
                        l.nodeCache[s].timestamp = l.nodeCacheTimestamp++;
                        l.nodeCache[s].diff = t.diff;
                        l.currentNodes.push(l.nodeCache[s]);
                        break
                    }
                if (e || (t.timestamp = l.nodeCacheTimestamp++, l.currentNodes.push(t), l.nodeCache.push(t)), t.level < l.level) {
                    var o = a.cubeResolution * Math.pow(2, t.level - a.maxLevel),
                        e = Math.ceil(o * a.invTileResolution) - 1,
                        s = o % a.tileResolution * 2,
                        c = 2 * o % a.tileResolution;
                    0 === c && (c = a.tileResolution);
                    0 === s && (s = 2 * a.tileResolution);
                    h = .5;
                    (t.x == e || t.y == e) && (h = 1 - a.tileResolution / (a.tileResolution + c));
                    var p = 1 - h,
                        o = [],
                        w = h,
                        b = h,
                        v = h,
                        k = p,
                        d = p,
                        y = p;
                    for (c < a.tileResolution && (t.x == e && t.y != e ? (d = b = .5, "d" == t.side || "u" == t.side) && (y = v = .5) : t.x != e && t.y == e && (k = w = .5, "l" == t.side || "r" == t.side) && (y = v = .5)), s <= a.tileResolution && (t.x == e && (w = 0, k = 1, "l" == t.side || "r" == t.side) && (v = 0, y = 1), t.y == e && (b = 0, d = 1, "d" == t.side || "u" == t.side) && (v = 0, y = 1)), c = [f[0], f[1], f[2], f[0] * w + f[3] * k, f[1] * h + f[4] * p, f[2] * v + f[5] * y, f[0] * w + f[6] * k, f[1] * b + f[7] * d, f[2] * v + f[8] * y, f[0] * h + f[9] * p, f[1] * b + f[10] * d, f[2] * v + f[11] * y], c = new nt(c, t.side, t.level + 1, 2 * t.x, 2 * t.y, a.fullpath), o.push(c), t.x == e && s <= a.tileResolution || (c = [f[0] * w + f[3] * k, f[1] * h + f[4] * p, f[2] * v + f[5] * y, f[3], f[4], f[5], f[3] * h + f[6] * p, f[4] * b + f[7] * d, f[5] * v + f[8] * y, f[0] * w + f[6] * k, f[1] * b + f[7] * d, f[2] * v + f[8] * y], c = new nt(c, t.side, t.level + 1, 2 * t.x + 1, 2 * t.y, a.fullpath), o.push(c)), t.x == e && s <= a.tileResolution || t.y == e && s <= a.tileResolution || (c = [f[0] * w + f[6] * k, f[1] * b + f[7] * d, f[2] * v + f[8] * y, f[3] * h + f[6] * p, f[4] * b + f[7] * d, f[5] * v + f[8] * y, f[6], f[7], f[8], f[9] * w + f[6] * k, f[10] * h + f[7] * p, f[11] * v + f[8] * y], c = new nt(c, t.side, t.level + 1, 2 * t.x + 1, 2 * t.y + 1, a.fullpath), o.push(c)), t.y == e && s <= a.tileResolution || (c = [f[0] * h + f[9] * p, f[1] * b + f[10] * d, f[2] * v + f[11] * y, f[0] * w + f[6] * k, f[1] * b + f[7] * d, f[2] * v + f[8] * y, f[9] * w + f[6] * k, f[10] * h + f[7] * p, f[11] * v + f[8] * y, f[9], f[10], f[11]], c = new nt(c, t.side, t.level + 1, 2 * t.x, 2 * t.y + 1, a.fullpath), o.push(c)), t = 0; t < o.length; t++) ht(n, o[t], i, r, u)
                }
            }
        }

        function ct() {
            return [-1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, -1, 1, 1, 1, 1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1, -1, 1, 1, -1, 1, -1, -1, -1, -1, -1, -1, 1, 1, 1, -1, 1, 1, 1, 1, -1, 1, 1, -1, -1]
        }

        function ut(n, t, i) {
            var r = Math.sin(t);
            return (t = Math.cos(t), "x" == i) ? [n[0], t * n[1] + r * n[2], t * n[2] - r * n[1], n[3], t * n[4] + r * n[5], t * n[5] - r * n[4], n[6], t * n[7] + r * n[8], t * n[8] - r * n[7]] : "y" == i ? [t * n[0] - r * n[2], n[1], t * n[2] + r * n[0], t * n[3] - r * n[5], n[4], t * n[5] + r * n[3], t * n[6] - r * n[8], n[7], t * n[8] + r * n[6]] : "z" == i ? [t * n[0] + r * n[1], t * n[1] - r * n[0], n[2], t * n[3] + r * n[4], t * n[4] - r * n[3], n[5], t * n[6] + r * n[7], t * n[7] - r * n[6], n[8]] : void 0
        }

        function lt(n) {
            return [n[0], n[4], n[8], n[12], n[1], n[5], n[9], n[13], n[2], n[6], n[10], n[14], n[3], n[7], n[11], n[15]]
        }

        function bt(n) {
            yt(n, n.path + "." + a.extension, function(t, i) {
                n.texture = t;
                n.textureLoaded = i ? 2 : 1
            }, rt.crossOrigin)
        }

        function tt(n, t) {
            var i = [n[0] * t[0] + n[1] * t[1] + n[2] * t[2], n[4] * t[0] + n[5] * t[1] + n[6] * t[2], n[11] + n[8] * t[0] + n[9] * t[1] + n[10] * t[2], 1 / (n[12] * t[0] + n[13] * t[1] + n[14] * t[2])],
                u = i[0] * i[3],
                f = i[1] * i[3],
                i = i[2] * i[3],
                r = [0, 0, 0];
            return -1 > u && (r[0] = -1), 1 < u && (r[0] = 1), -1 > f && (r[1] = -1), 1 < f && (r[1] = 1), (-1 > i || 1 < i) && (r[2] = 1), r
        }

        function at() {
            console.log("Reducing canvas size due to error 1286!");
            y.width = Math.round(y.width / 2);
            y.height = Math.round(y.height / 2)
        }
        var y = t.createElement("canvas"),
            l, c, w, b, d, p, ft, g, a, v, vt, et, ot, it, st, rt, k, yt;
        y.style.width = y.style.height = "100%";
        u.appendChild(y);
        this.init = function(n, k, nt, tt, ut, ht, lt, yt) {
            function ni(n) {
                var i;
                if (bt) {
                    var u = n * n * 4,
                        r = new Uint8ClampedArray(u),
                        t = yt.backgroundColor ? yt.backgroundColor : [0, 0, 0];
                    for (t[0] *= 255, t[1] *= 255, t[2] *= 255, i = 0; i < u; i++) r[i++] = t[0], r[i++] = t[1], r[i++] = t[2];
                    for (n = new ImageData(r, n, n), wt = 0; 6 > wt; wt++) 0 == a[wt].width && (a[wt] = n)
                }
            }
            var wt, pt, kt, dt, gt, bt;
            if (k === i && (k = "equirectangular"), "equirectangular" != k && "cubemap" != k && "multires" != k) throw console.log("Error: invalid image type specified!"), {
                type: "config error"
            };
            if (v = k, a = n, vt = nt, rt = yt || {}, l) {
                if (w && (c.detachShader(l, w), c.deleteShader(w)), b && (c.detachShader(l, b), c.deleteShader(b)), c.bindBuffer(c.ARRAY_BUFFER, null), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, null), l.texture && c.deleteTexture(l.texture), l.nodeCache)
                    for (n = 0; n < l.nodeCache.length; n++) c.deleteTexture(l.nodeCache[n].texture);
                c.deleteProgram(l);
                l = i
            }
            if (g = i, bt = !1, "cubemap" == v)
                for (wt = 0; 6 > wt; wt++) 0 < a[wt].width ? (pt === i && (pt = a[wt].width), pt != a[wt].width && console.log("Cube faces have inconsistent widths: " + pt + " vs. " + a[wt].width)) : bt = !0;
            if ("cubemap" == v && 0 != (pt & pt - 1) && (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/) || navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 9_/) || navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 10_/) || navigator.userAgent.match(/Trident.*rv[ :]*11\./)) || (c || (c = y.getContext("experimental-webgl", {
                    alpha: !1,
                    depth: !1
                })), c && 1286 == c.getError() && at()), !c && ("multires" == v && a.hasOwnProperty("fallbackPath") || "cubemap" == v) && ("WebkitAppearance" in t.documentElement.style || navigator.userAgent.match(/Trident.*rv[ :]*11\./) || -1 !== navigator.appVersion.indexOf("MSIE 10"))) {
                for (p && u.removeChild(p), p = t.createElement("div"), p.className = "pnlm-world", tt = a.basePath ? a.basePath + a.fallbackPath : a.fallbackPath, kt = "frblud".split(""), dt = 0, ut = function() {
                        var n = t.createElement("canvas"),
                            f, e, r, u, i;
                        for (n.className = "pnlm-face pnlm-" + kt[this.side] + "face", p.appendChild(n), f = n.getContext("2d"), n.style.width = this.width + 4 + "px", n.style.height = this.height + 4 + "px", n.width = this.width + 4, n.height = this.height + 4, f.drawImage(this, 2, 2), e = f.getImageData(0, 0, n.width, n.height), r = e.data, u = 2; u < n.width - 2; u++)
                            for (i = 0; 4 > i; i++) r[4 * (u + n.width) + i] = r[4 * (u + 2 * n.width) + i], r[4 * (u + n.width * (n.height - 2)) + i] = r[4 * (u + n.width * (n.height - 3)) + i];
                        for (u = 2; u < n.height - 2; u++)
                            for (i = 0; 4 > i; i++) r[4 * (u * n.width + 1) + i] = r[4 * (u * n.width + 2) + i], r[4 * ((u + 1) * n.width - 2) + i] = r[4 * ((u + 1) * n.width - 3) + i];
                        for (i = 0; 4 > i; i++) r[4 * (n.width + 1) + i] = r[4 * (2 * n.width + 2) + i], r[4 * (2 * n.width - 2) + i] = r[4 * (3 * n.width - 3) + i], r[4 * (n.width * (n.height - 2) + 1) + i] = r[4 * (n.width * (n.height - 3) + 2) + i], r[4 * (n.width * (n.height - 1) - 2) + i] = r[4 * (n.width * (n.height - 2) - 3) + i];
                        for (u = 1; u < n.width - 1; u++)
                            for (i = 0; 4 > i; i++) r[4 * u + i] = r[4 * (u + n.width) + i], r[4 * (u + n.width * (n.height - 1)) + i] = r[4 * (u + n.width * (n.height - 2)) + i];
                        for (u = 1; u < n.height - 1; u++)
                            for (i = 0; 4 > i; i++) r[u * n.width * 4 + i] = r[4 * (u * n.width + 1) + i], r[4 * ((u + 1) * n.width - 1) + i] = r[4 * ((u + 1) * n.width - 2) + i];
                        for (i = 0; 4 > i; i++) r[i] = r[4 * (n.width + 1) + i], r[4 * (n.width - 1) + i] = r[4 * (2 * n.width - 2) + i], r[n.width * (n.height - 1) * 4 + i] = r[4 * (n.width * (n.height - 2) + 1) + i], r[4 * (n.width * n.height - 1) + i] = r[4 * (n.width * (n.height - 1) - 2) + i];
                        f.putImageData(e, 0, 0);
                        gt.call(this)
                    }, gt = function() {
                        0 < this.width ? (d === i && (d = this.width), d != this.width && console.log("Fallback faces have inconsistent widths: " + d + " vs. " + this.width)) : bt = !0;
                        dt++;
                        6 == dt && (d = this.width, u.appendChild(p), lt())
                    }, bt = !1, wt = 0; 6 > wt; wt++) ht = new Image, ht.crossOrigin = rt.crossOrigin ? rt.crossOrigin : "anonymous", ht.side = wt, ht.onload = ut, ht.onerror = gt, ht.src = "multires" == v ? tt.replace("%s", kt[wt]) + "." + a.extension : a[wt].src;
                ni(d)
            } else {
                if (!c) throw console.log("Error: no WebGL support detected!"), {
                    type: "no webgl"
                };
                for ("cubemap" == v && ni(pt), a.fullpath = a.basePath ? a.basePath + a.path : a.path, a.invTileResolution = 1 / a.tileResolution, n = ct(), ft = [], wt = 0; 6 > wt; wt++) ft[wt] = n.slice(12 * wt, 12 * wt + 12), n = ct();
                if (n = 0, "equirectangular" == v) {
                    if (n = c.getParameter(c.MAX_TEXTURE_SIZE), Math.max(a.width / 2, a.height) > n) throw console.log("Error: The image is too big; it's " + a.width + "px wide, but this device's maximum supported size is " + 2 * n + "px."), {
                        type: "webgl size error",
                        width: a.width,
                        maxWidth: 2 * n
                    };
                } else if ("cubemap" == v && pt > c.getParameter(c.MAX_CUBE_MAP_TEXTURE_SIZE)) throw console.log("Error: The image is too big; it's " + pt + "px wide, but this device's maximum supported size is " + n + "px."), {
                    type: "webgl size error",
                    width: pt,
                    maxWidth: n
                };
                if (yt === i || yt.horizonPitch === i && yt.horizonRoll === i || (g = [yt.horizonPitch == i ? 0 : yt.horizonPitch, yt.horizonRoll == i ? 0 : yt.horizonRoll]), pt = c.TEXTURE_2D, c.viewport(0, 0, c.drawingBufferWidth, c.drawingBufferHeight), c.getShaderPrecisionFormat && (k = c.getShaderPrecisionFormat(c.FRAGMENT_SHADER, c.HIGH_FLOAT)) && 1 > k.precision && (r = r.replace("highp", "mediump")), w = c.createShader(c.VERTEX_SHADER), k = f, "multires" == v && (k = e), c.shaderSource(w, k), c.compileShader(w), b = c.createShader(c.FRAGMENT_SHADER), k = s, "cubemap" == v ? (pt = c.TEXTURE_CUBE_MAP, k = o) : "multires" == v && (k = h), c.shaderSource(b, k), c.compileShader(b), l = c.createProgram(), c.attachShader(l, w), c.attachShader(l, b), c.linkProgram(l), c.getShaderParameter(w, c.COMPILE_STATUS) || console.log(c.getShaderInfoLog(w)), c.getShaderParameter(b, c.COMPILE_STATUS) || console.log(c.getShaderInfoLog(b)), c.getProgramParameter(l, c.LINK_STATUS) || console.log(c.getProgramInfoLog(l)), c.useProgram(l), l.drawInProgress = !1, k = yt.backgroundColor ? yt.backgroundColor : [0, 0, 0], c.clearColor(k[0], k[1], k[2], 1), c.clear(c.COLOR_BUFFER_BIT), l.texCoordLocation = c.getAttribLocation(l, "a_texCoord"), c.enableVertexAttribArray(l.texCoordLocation), "multires" != v ? (et || (et = c.createBuffer()), c.bindBuffer(c.ARRAY_BUFFER, et), c.bufferData(c.ARRAY_BUFFER, new Float32Array([-1, 1, 1, 1, 1, -1, -1, 1, 1, -1, -1, -1]), c.STATIC_DRAW), c.vertexAttribPointer(l.texCoordLocation, 2, c.FLOAT, !1, 0, 0), l.aspectRatio = c.getUniformLocation(l, "u_aspectRatio"), c.uniform1f(l.aspectRatio, c.drawingBufferWidth / c.drawingBufferHeight), l.psi = c.getUniformLocation(l, "u_psi"), l.theta = c.getUniformLocation(l, "u_theta"), l.f = c.getUniformLocation(l, "u_f"), l.h = c.getUniformLocation(l, "u_h"), l.v = c.getUniformLocation(l, "u_v"), l.vo = c.getUniformLocation(l, "u_vo"), l.rot = c.getUniformLocation(l, "u_rot"), c.uniform1f(l.h, tt / (2 * Math.PI)), c.uniform1f(l.v, ut / Math.PI), c.uniform1f(l.vo, ht / Math.PI * 2), "equirectangular" == v && (l.backgroundColor = c.getUniformLocation(l, "u_backgroundColor"), c.uniform4fv(l.backgroundColor, k.concat([1]))), l.texture = c.createTexture(), c.bindTexture(pt, l.texture), "cubemap" == v ? (c.texImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_X, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a[1]), c.texImage2D(c.TEXTURE_CUBE_MAP_NEGATIVE_X, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a[3]), c.texImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_Y, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a[4]), c.texImage2D(c.TEXTURE_CUBE_MAP_NEGATIVE_Y, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a[5]), c.texImage2D(c.TEXTURE_CUBE_MAP_POSITIVE_Z, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a[0]), c.texImage2D(c.TEXTURE_CUBE_MAP_NEGATIVE_Z, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a[2])) : a.width <= n ? (c.uniform1i(c.getUniformLocation(l, "u_splitImage"), 0), c.texImage2D(pt, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a)) : (c.uniform1i(c.getUniformLocation(l, "u_splitImage"), 1), tt = t.createElement("canvas"), tt.width = a.width / 2, tt.height = a.height, tt = tt.getContext("2d"), tt.drawImage(a, 0, 0), ut = tt.getImageData(0, 0, a.width / 2, a.height), c.texImage2D(pt, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, ut), l.texture2 = c.createTexture(), c.activeTexture(c.TEXTURE1), c.bindTexture(pt, l.texture2), c.uniform1i(c.getUniformLocation(l, "u_image1"), 1), tt.drawImage(a, -a.width / 2, 0), ut = tt.getImageData(0, 0, a.width / 2, a.height), c.texImage2D(pt, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, ut), c.texParameteri(pt, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(pt, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(pt, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(pt, c.TEXTURE_MAG_FILTER, c.LINEAR), c.activeTexture(c.TEXTURE0)), c.texParameteri(pt, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE), c.texParameteri(pt, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE), c.texParameteri(pt, c.TEXTURE_MIN_FILTER, c.LINEAR), c.texParameteri(pt, c.TEXTURE_MAG_FILTER, c.LINEAR)) : (l.vertPosLocation = c.getAttribLocation(l, "a_vertCoord"), c.enableVertexAttribArray(l.vertPosLocation), ot || (ot = c.createBuffer()), it || (it = c.createBuffer()), st || (st = c.createBuffer()), c.bindBuffer(c.ARRAY_BUFFER, it), c.bufferData(c.ARRAY_BUFFER, new Float32Array([0, 0, 1, 0, 1, 1, 0, 1]), c.STATIC_DRAW), c.bindBuffer(c.ELEMENT_ARRAY_BUFFER, st), c.bufferData(c.ELEMENT_ARRAY_BUFFER, new Uint16Array([0, 1, 2, 0, 2, 3]), c.STATIC_DRAW), l.perspUniform = c.getUniformLocation(l, "u_perspMatrix"), l.cubeUniform = c.getUniformLocation(l, "u_cubeMatrix"), l.level = -1, l.currentNodes = [], l.nodeCache = [], l.nodeCacheTimestamp = 0), tt = c.getError(), 0 !== tt) throw console.log("Error: Something went wrong with WebGL!", tt), {
                    type: "webgl error"
                };
                lt()
            }
        };
        this.destroy = function() {
            if (u !== i && (y !== i && u.contains(y) && u.removeChild(y), p !== i && u.contains(p) && u.removeChild(p)), c) {
                var n = c.getExtension("WEBGL_lose_context");
                n && n.loseContext()
            }
        };
        this.resize = function() {
            var t = n.devicePixelRatio || 1;
            y.width = y.clientWidth * t;
            y.height = y.clientHeight * t;
            c && (1286 == c.getError() && at(), c.viewport(0, 0, c.drawingBufferWidth, c.drawingBufferHeight), "multires" != v && c.uniform1f(l.aspectRatio, y.clientWidth / y.clientHeight))
        };
        this.resize();
        this.setPose = function(n, t) {
            g = [n, t]
        };
        this.render = function(n, t, r, u) {
            var e, o = 0;
            if (u === i && (u = {}), u.roll && (o = u.roll), g !== i) {
                e = g[0];
                var f = g[1],
                    s = n,
                    h = t,
                    w = Math.cos(f) * Math.sin(n) * Math.sin(e) + Math.cos(n) * (Math.cos(e) * Math.cos(t) + Math.sin(f) * Math.sin(e) * Math.sin(t)),
                    b = -Math.sin(n) * Math.sin(f) + Math.cos(n) * Math.cos(f) * Math.sin(t);
                n = Math.cos(f) * Math.cos(e) * Math.sin(n) + Math.cos(n) * (-Math.cos(t) * Math.sin(e) + Math.cos(e) * Math.sin(f) * Math.sin(t));
                n = Math.asin(Math.max(Math.min(n, 1), -1));
                t = Math.atan2(b, w);
                e = [Math.cos(s) * (Math.sin(f) * Math.sin(e) * Math.cos(h) - Math.cos(e) * Math.sin(h)), Math.cos(s) * Math.cos(f) * Math.cos(h), Math.cos(s) * (Math.cos(e) * Math.sin(f) * Math.cos(h) + Math.sin(h) * Math.sin(e))];
                f = [-Math.cos(n) * Math.sin(t), Math.cos(n) * Math.cos(t)];
                f = Math.acos(Math.max(Math.min((e[0] * f[0] + e[1] * f[1]) / (Math.sqrt(e[0] * e[0] + e[1] * e[1] + e[2] * e[2]) * Math.sqrt(f[0] * f[0] + f[1] * f[1])), 1), -1));
                0 > e[2] && (f = 2 * Math.PI - f);
                o += f
            }
            if (c || "multires" != v && "cubemap" != v) {
                if ("multires" != v) r = 2 * Math.atan(Math.tan(.5 * r) / (c.drawingBufferWidth / c.drawingBufferHeight)), r = 1 / Math.tan(.5 * r), c.uniform1f(l.psi, t), c.uniform1f(l.theta, n), c.uniform1f(l.rot, o), c.uniform1f(l.f, r), !0 === vt && "equirectangular" == v && (c.bindTexture(c.TEXTURE_2D, l.texture), c.texImage2D(c.TEXTURE_2D, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, a)), c.drawArrays(c.TRIANGLES, 0, 6);
                else {
                    for (e = c.drawingBufferWidth / c.drawingBufferHeight, f = 2 * Math.atan(Math.tan(r / 2) * c.drawingBufferHeight / c.drawingBufferWidth), f = 1 / Math.tan(f / 2), e = [f / e, 0, 0, 0, 0, f, 0, 0, 0, 0, 100.1 / -99.9, 20 / -99.9, 0, 0, -1, 0], f = 1; f < a.maxLevel && c.drawingBufferWidth > a.tileResolution * Math.pow(2, f - 1) * Math.tan(r / 2) * .707;) f++;
                    if (l.level = f, f = [1, 0, 0, 0, 1, 0, 0, 0, 1], f = ut(f, -o, "z"), f = ut(f, -n, "x"), f = ut(f, t, "y"), f = [f[0], f[1], f[2], 0, f[3], f[4], f[5], 0, f[6], f[7], f[8], 0, 0, 0, 0, 1], c.uniformMatrix4fv(l.perspUniform, !1, new Float32Array(lt(e))), c.uniformMatrix4fv(l.cubeUniform, !1, new Float32Array(lt(f))), o = [e[0] * f[0], e[0] * f[1], e[0] * f[2], 0, e[5] * f[4], e[5] * f[5], e[5] * f[6], 0, e[10] * f[8], e[10] * f[9], e[10] * f[10], e[11], -f[8], -f[9], -f[10], 0], l.nodeCache.sort(pt), 200 < l.nodeCache.length && l.nodeCache.length > l.currentNodes.length + 50)
                        for (e = l.nodeCache.splice(200, l.nodeCache.length - 200), f = 0; f < e.length; f++) c.deleteTexture(e[f].texture);
                    for (l.currentNodes = [], f = "fbudlr".split(""), e = 0; 6 > e; e++) s = new nt(ft[e], f[e], 1, 0, 0, a.fullpath), ht(o, s, n, t, r);
                    for (l.currentNodes.sort(wt), n = k.length - 1; 0 <= n; n--) - 1 === l.currentNodes.indexOf(k[n].node) && (k[n].node.textureLoad = !1, k.splice(n, 1));
                    if (0 === k.length)
                        for (n = 0; n < l.currentNodes.length; n++)
                            if (t = l.currentNodes[n], !t.texture && !t.textureLoad) {
                                t.textureLoad = !0;
                                setTimeout(bt, 0, t);
                                break
                            }
                    if (!l.drawInProgress) {
                        for (l.drawInProgress = !0, c.clear(c.COLOR_BUFFER_BIT), n = 0; n < l.currentNodes.length; n++) 1 < l.currentNodes[n].textureLoaded && (c.bindBuffer(c.ARRAY_BUFFER, ot), c.bufferData(c.ARRAY_BUFFER, new Float32Array(l.currentNodes[n].vertices), c.STATIC_DRAW), c.vertexAttribPointer(l.vertPosLocation, 3, c.FLOAT, !1, 0, 0), c.bindBuffer(c.ARRAY_BUFFER, it), c.vertexAttribPointer(l.texCoordLocation, 2, c.FLOAT, !1, 0, 0), c.bindTexture(c.TEXTURE_2D, l.currentNodes[n].texture), c.drawElements(c.TRIANGLES, 6, c.UNSIGNED_SHORT, 0));
                        l.drawInProgress = !1
                    }
                }
                if (u.returnImage !== i) return y.toDataURL("image/png")
            } else
                for (e = d / 2, u = {
                        f: "translate3d(-" + (e + 2) + "px, -" + (e + 2) + "px, -" + e + "px)",
                        b: "translate3d(" + (e + 2) + "px, -" + (e + 2) + "px, " + e + "px) rotateX(180deg) rotateZ(180deg)",
                        u: "translate3d(-" + (e + 2) + "px, -" + e + "px, " + (e + 2) + "px) rotateX(270deg)",
                        d: "translate3d(-" + (e + 2) + "px, " + e + "px, -" + (e + 2) + "px) rotateX(90deg)",
                        l: "translate3d(-" + e + "px, -" + (e + 2) + "px, " + (e + 2) + "px) rotateX(180deg) rotateY(90deg) rotateZ(180deg)",
                        r: "translate3d(" + e + "px, -" + (e + 2) + "px, -" + (e + 2) + "px) rotateY(270deg)"
                    }, r = 1 / Math.tan(r / 2), r = r * y.clientWidth / 2 + "px", t = "perspective(" + r + ") translateZ(" + r + ") rotateX(" + n + "rad) rotateY(" + t + "rad) ", r = Object.keys(u), n = 0; 6 > n; n++)(o = p.querySelector(".pnlm-" + r[n] + "face")) && (o.style.webkitTransform = t + u[r[n]], o.style.transform = t + u[r[n]])
        };
        this.isLoading = function() {
            if (c && "multires" == v)
                for (var n = 0; n < l.currentNodes.length; n++)
                    if (!l.currentNodes[n].textureLoaded) return !0;
            return !1
        };
        this.getCanvas = function() {
            return y
        };
        k = [];
        yt = function() {
            function u() {
                var t = this,
                    u;
                this.texture = this.callback = null;
                this.image = new Image;
                this.image.crossOrigin = r ? r : "anonymous";
                u = function() {
                    if (0 < t.image.width && 0 < t.image.height) {
                        var r = t.image;
                        c.bindTexture(c.TEXTURE_2D, t.texture);
                        c.texImage2D(c.TEXTURE_2D, 0, c.RGB, c.RGB, c.UNSIGNED_BYTE, r);
                        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MAG_FILTER, c.LINEAR);
                        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_MIN_FILTER, c.LINEAR);
                        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_S, c.CLAMP_TO_EDGE);
                        c.texParameteri(c.TEXTURE_2D, c.TEXTURE_WRAP_T, c.CLAMP_TO_EDGE);
                        c.bindTexture(c.TEXTURE_2D, null);
                        t.callback(t.texture, !0)
                    } else t.callback(t.texture, !1);
                    k.length ? (r = k.shift(), t.loadTexture(r.src, r.texture, r.callback)) : i[n++] = t
                };
                this.image.addEventListener("load", u);
                this.image.addEventListener("error", u)
            }

            function f(n, t, i, r) {
                this.node = n;
                this.src = t;
                this.texture = i;
                this.callback = r
            }
            var n = 4,
                i = {},
                r, t;
            for (u.prototype.loadTexture = function(n, t, i) {
                    this.texture = t;
                    this.callback = i;
                    this.image.src = n
                }, t = 0; t < n; t++) i[t] = new u;
            return function(t, u, e, o) {
                return r = o, o = c.createTexture(), n ? i[--n].loadTexture(u, o, e) : k.push(new f(t, u, o, e)), o
            }
        }()
    }
    var f = "attribute vec2 a_texCoord;varying vec2 v_texCoord;void main() {gl_Position = vec4(a_texCoord, 0.0, 1.0);v_texCoord = a_texCoord;}",
        e = "attribute vec3 a_vertCoord;attribute vec2 a_texCoord;uniform mat4 u_cubeMatrix;uniform mat4 u_perspMatrix;varying mediump vec2 v_texCoord;void main(void) {gl_Position = u_perspMatrix * u_cubeMatrix * vec4(a_vertCoord, 1.0);v_texCoord = a_texCoord;}",
        r = "precision highp float;\nuniform float u_aspectRatio;\nuniform float u_psi;\nuniform float u_theta;\nuniform float u_f;\nuniform float u_h;\nuniform float u_v;\nuniform float u_vo;\nuniform float u_rot;\nconst float PI = 3.14159265358979323846264;\nuniform sampler2D u_image0;\nuniform sampler2D u_image1;\nuniform bool u_splitImage;\nuniform samplerCube u_imageCube;\nvarying vec2 v_texCoord;\nuniform vec4 u_backgroundColor;\nvoid main() {\nfloat x = v_texCoord.x * u_aspectRatio;\nfloat y = v_texCoord.y;\nfloat sinrot = sin(u_rot);\nfloat cosrot = cos(u_rot);\nfloat rot_x = x * cosrot - y * sinrot;\nfloat rot_y = x * sinrot + y * cosrot;\nfloat sintheta = sin(u_theta);\nfloat costheta = cos(u_theta);\nfloat a = u_f * costheta - rot_y * sintheta;\nfloat root = sqrt(rot_x * rot_x + a * a);\nfloat lambda = atan(rot_x / root, a / root) + u_psi;\nfloat phi = atan((rot_y * costheta + u_f * sintheta) / root);",
        o = r + "float cosphi = cos(phi);\ngl_FragColor = textureCube(u_imageCube, vec3(cosphi*sin(lambda), sin(phi), cosphi*cos(lambda)));\n}",
        s = r + "lambda = mod(lambda + PI, PI * 2.0) - PI;\nvec2 coord = vec2(lambda / PI, phi / (PI / 2.0));\nif(coord.x < -u_h || coord.x > u_h || coord.y < -u_v + u_vo || coord.y > u_v + u_vo)\ngl_FragColor = u_backgroundColor;\nelse {\nif(u_splitImage) {\nif(coord.x < 0.0)\ngl_FragColor = texture2D(u_image0, vec2((coord.x + u_h) / u_h, (-coord.y + u_v + u_vo) / (u_v * 2.0)));\nelse\ngl_FragColor = texture2D(u_image1, vec2((coord.x + u_h) / u_h - 1.0, (-coord.y + u_v + u_vo) / (u_v * 2.0)));\n} else {\ngl_FragColor = texture2D(u_image0, vec2((coord.x + u_h) / (u_h * 2.0), (-coord.y + u_v + u_vo) / (u_v * 2.0)));\n}\n}\n}",
        h = "varying mediump vec2 v_texCoord;uniform sampler2D u_sampler;void main(void) {gl_FragColor = texture2D(u_sampler, v_texCoord);}";
    return {
        renderer: function(n, t, i, r) {
            return new u(n, t, i, r)
        }
    }
}(window, document);
window.pannellum = function(n, t, i) {
    function r(r, u) {
        function cr() {
            var r = t.createElement("div"),
                u, o;
            if (r.innerHTML = "<!--[if lte IE 9]><i><\/i><![endif]-->", 1 == r.getElementsByTagName("i").length) et();
            else {
                if (pt = f.hfov, hi = f.pitch, "cubemap" == f.type) {
                    for (b = [], r = 0; 6 > r; r++) b.push(new Image), b[r].crossOrigin = f.crossOrigin;
                    e.load.lbox.style.display = "block";
                    e.load.lbar.style.display = "none"
                } else if ("multires" == f.type) r = JSON.parse(JSON.stringify(f.multiRes)), f.basePath && f.multiRes.basePath && !/^(?:[a-z]+:)?\/\//i.test(f.multiRes.basePath) ? r.basePath = f.basePath + f.multiRes.basePath : f.multiRes.basePath ? r.basePath = f.multiRes.basePath : f.basePath && (r.basePath = f.basePath), b = r;
                else if (!0 === f.dynamic) b = f.panorama;
                else {
                    if (f.panorama === i) {
                        et(f.strings.noPanoramaError);
                        return
                    }
                    b = new Image
                }
                if ("cubemap" == f.type)
                    for (var s = 6, h = function() {
                            s--;
                            0 === s && ni()
                        }, c = function(n) {
                            var i = t.createElement("a");
                            i.href = n.target.src;
                            i.textContent = i.href;
                            et(f.strings.fileAccessError.replace("%s", i.outerHTML))
                        }, r = 0; r < b.length; r++) u = f.cubeMap[r], "null" == u ? (console.log("Will use background instead of missing cubemap face " + r), h()) : (f.basePath && !gt(u) && (u = f.basePath + u), b[r].onload = h, b[r].onerror = c, b[r].src = at(u));
                else if ("multires" == f.type) ni();
                else if (u = "", f.basePath && (u = f.basePath), !0 !== f.dynamic) {
                    u = gt(f.panorama) ? f.panorama : u + f.panorama;
                    b.onload = function() {
                        n.URL.revokeObjectURL(this.src);
                        ni()
                    };
                    o = new XMLHttpRequest;
                    o.onloadend = function() {
                        if (200 != o.status) {
                            var n = t.createElement("a");
                            n.href = u;
                            n.textContent = n.href;
                            et(f.strings.fileAccessError.replace("%s", n.outerHTML))
                        }
                        fu(this.response);
                        e.load.msg.innerHTML = ""
                    };
                    o.onprogress = function(n) {
                        if (n.lengthComputable) {
                            e.load.lbarFill.style.width = n.loaded / n.total * 100 + "%";
                            var t, i;
                            1e6 < n.total ? (t = "MB", i = (n.loaded / 1e6).toFixed(2), n = (n.total / 1e6).toFixed(2)) : 1e3 < n.total ? (t = "kB", i = (n.loaded / 1e3).toFixed(1), n = (n.total / 1e3).toFixed(1)) : (t = "B", i = n.loaded, n = n.total);
                            e.load.msg.innerHTML = i + " / " + n + " " + t
                        } else e.load.lbox.style.display = "block", e.load.lbar.style.display = "none"
                    };
                    try {
                        o.open("GET", u, !0)
                    } catch (l) {
                        et(f.strings.malformedURLError)
                    }
                    o.responseType = "blob";
                    o.setRequestHeader("Accept", "image/*,*/*;q=0.9");
                    o.withCredentials = "use-credentials" === f.crossOrigin;
                    o.send()
                }
                f.draggable && a.classList.add("pnlm-grab");
                a.classList.remove("pnlm-grabbing");
                wi = !0 === f.dynamicUpdate;
                f.dynamic && wi && (b = f.panorama, ni())
            }
        }

        function gt(n) {
            return /^(?:[a-z]+:)?\/\//i.test(n) || "/" == n[0] || "blob:" == n.slice(0, 5)
        }

        function ni() {
            c || (c = new libpannellum.renderer(y));
            er || (er = !0, g.addEventListener("mousedown", eu, !1), t.addEventListener("mousemove", lr, !1), t.addEventListener("mouseup", ci, !1), f.mouseZoom && (a.addEventListener("mousewheel", wr, !1), a.addEventListener("DOMMouseScroll", wr, !1)), f.doubleClickZoom && g.addEventListener("dblclick", ou, !1), r.addEventListener("mozfullscreenchange", ot, !1), r.addEventListener("webkitfullscreenchange", ot, !1), r.addEventListener("msfullscreenchange", ot, !1), r.addEventListener("fullscreenchange", ot, !1), n.addEventListener("resize", ii, !1), n.addEventListener("orientationchange", ii, !1), f.disableKeyboardCtrl || (r.addEventListener("keydown", br, !1), r.addEventListener("keyup", dr, !1), r.addEventListener("blur", kr, !1)), t.addEventListener("mouseleave", ci, !1), "" === t.documentElement.style.pointerAction && "" === t.documentElement.style.touchAction ? (g.addEventListener("pointerdown", su, !1), g.addEventListener("pointermove", hu, !1), g.addEventListener("pointerup", pr, !1), g.addEventListener("pointerleave", pr, !1)) : (g.addEventListener("touchstart", ar, !1), g.addEventListener("touchmove", vr, !1), g.addEventListener("touchend", yr, !1)), n.navigator.pointerEnabled && (r.style.touchAction = "none"));
            au();
            k(f.hfov);
            setTimeout(function() {}, 500)
        }

        function fu(t) {
            var r = new FileReader;
            r.addEventListener("loadend", function() {
                var o = r.result,
                    e;
                if (navigator.userAgent.toLowerCase().match(/(iphone|ipod|ipad).* os 8_/) && (e = o.indexOf("ÿÂ"), (0 > e || 65536 < e) && et(f.strings.iOS8WebGLError)), e = o.indexOf("<x:xmpmeta"), -1 < e && !0 !== f.ignoreGPanoXMP) {
                    var s = o.substring(e, o.indexOf("<\/x:xmpmeta>") + 12),
                        u = function(n) {
                            var t;
                            return 0 <= s.indexOf(n + '="') ? (t = s.substring(s.indexOf(n + '="') + n.length + 2), t = t.substring(0, t.indexOf('"'))) : 0 <= s.indexOf(n + ">") && (t = s.substring(s.indexOf(n + ">") + n.length + 1), t = t.substring(0, t.indexOf("<"))), t !== i ? Number(t) : null
                        },
                        o = u("GPano:FullPanoWidthPixels"),
                        e = u("GPano:CroppedAreaImageWidthPixels"),
                        h = u("GPano:FullPanoHeightPixels"),
                        c = u("GPano:CroppedAreaImageHeightPixels"),
                        l = u("GPano:CroppedAreaTopPixels"),
                        a = u("GPano:PoseHeadingDegrees"),
                        v = u("GPano:PosePitchDegrees"),
                        u = u("GPano:PoseRollDegrees");
                    null !== o && null !== e && null !== h && null !== c && null !== l && (0 > ut.indexOf("haov") && (f.haov = e / o * 360), 0 > ut.indexOf("vaov") && (f.vaov = c / h * 180), 0 > ut.indexOf("vOffset") && (f.vOffset = -180 * ((l + c / 2) / h - .5)), null !== a && 0 > ut.indexOf("northOffset") && (f.northOffset = a, !1 !== f.compass && (f.compass = !0)), null !== v && null !== u && (0 > ut.indexOf("horizonPitch") && (f.horizonPitch = v), 0 > ut.indexOf("horizonRoll") && (f.horizonRoll = u)))
                }
                b.src = n.URL.createObjectURL(t)
            });
            r.readAsBinaryString !== i ? r.readAsBinaryString(t) : r.readAsText(t)
        }

        function et(n) {
            n === i && (n = f.strings.genericWebGLError);
            e.errorMsg.innerHTML = "<p>" + n + "<\/p>";
            s.load.style.display = "none";
            e.load.box.style.display = "none";
            e.errorMsg.style.display = "table";
            yi = !0;
            l = i;
            y.style.display = "none";
            nt("error", n)
        }

        function ti(n) {
            var t = ct(n);
            ft.style.left = t.x + "px";
            ft.style.top = t.y + "px";
            clearTimeout(ti.t1);
            clearTimeout(ti.t2);
            ft.style.display = "block";
            ft.style.opacity = 1;
            ti.t1 = setTimeout(function() {
                ft.style.opacity = 0
            }, 2e3);
            ti.t2 = setTimeout(function() {
                ft.style.display = "none"
            }, 2500);
            n.preventDefault()
        }

        function ct(n) {
            var i = r.getBoundingClientRect(),
                t = {};
            return t.x = (n.clientX || n.pageX) - i.left, t.y = (n.clientY || n.pageY) - i.top, t
        }

        function eu(n) {
            var t, i;
            n.preventDefault();
            r.focus();
            l && f.draggable && (t = ct(n), f.hotSpotDebug && (i = di(n), console.log("Pitch: " + i[0] + ", Yaw: " + i[1] + ", Center Pitch: " + f.pitch + ", Center Yaw: " + f.yaw + ", HFOV: " + f.hfov)), ui(), fi(), f.roll = 0, h.hfov = 0, vt = !0, p = Date.now(), ei = t.x, oi = t.y, ai = f.yaw, vi = f.pitch, a.classList.add("pnlm-grabbing"), a.classList.remove("pnlm-grab"), nt("mousedown", n), v())
        }

        function ou(n) {
            f.minHfov === f.hfov ? st.setHfov(pt, 1e3) : (n = di(n), st.lookAt(n[0], n[1], f.minHfov, 1e3))
        }

        function di(n) {
            var r = ct(n),
                t, i;
            n = c.getCanvas();
            t = n.clientWidth;
            i = n.clientHeight;
            n = r.x / t * 2 - 1;
            var i = (1 - r.y / i * 2) * i / t,
                u = 1 / Math.tan(f.hfov * Math.PI / 360),
                e = Math.sin(f.pitch * Math.PI / 180),
                o = Math.cos(f.pitch * Math.PI / 180),
                r = u * o - i * e,
                t = Math.sqrt(n * n + r * r),
                i = 180 * Math.atan((i * o + u * e) / t) / Math.PI;
            return n = 180 * Math.atan2(n / t, r / t) / Math.PI + f.yaw, -180 > n && (n += 360), 180 < n && (n -= 360), [i, n]
        }

        function lr(n) {
            var r;
            if (vt && l) {
                p = Date.now();
                var i = c.getCanvas(),
                    t = i.clientWidth,
                    i = i.clientHeight;
                n = ct(n);
                r = 180 * (Math.atan(ei / t * 2 - 1) - Math.atan(n.x / t * 2 - 1)) / Math.PI * f.hfov / 90 + ai;
                h.yaw = (r - f.yaw) % 360 * .2;
                f.yaw = r;
                t = 360 * Math.atan(Math.tan(f.hfov / 360 * Math.PI) * i / t) / Math.PI;
                t = 180 * (Math.atan(n.y / i * 2 - 1) - Math.atan(oi / i * 2 - 1)) / Math.PI * t / 90 + vi;
                h.pitch = .2 * (t - f.pitch);
                f.pitch = t
            }
        }

        function ci(n) {
            vt && (vt = !1, 15 < Date.now() - p && (h.pitch = h.yaw = 0), a.classList.add("pnlm-grab"), a.classList.remove("pnlm-grabbing"), p = Date.now(), nt("mouseup", n))
        }

        function ar(n) {
            var t, i;
            l && f.draggable && (ui(), fi(), f.roll = 0, h.hfov = 0, t = ct(n.targetTouches[0]), ei = t.x, oi = t.y, 2 == n.targetTouches.length && (i = ct(n.targetTouches[1]), ei += .5 * (i.x - t.x), oi += .5 * (i.y - t.y), si = Math.sqrt((t.x - i.x) * (t.x - i.x) + (t.y - i.y) * (t.y - i.y))), vt = !0, p = Date.now(), ai = f.yaw, vi = f.pitch, nt("touchstart", n), v())
        }

        function vr(n) {
            if (f.draggable && (n.preventDefault(), l && (p = Date.now()), vt && l)) {
                var t = ct(n.targetTouches[0]),
                    i = t.x,
                    r = t.y;
                2 == n.targetTouches.length && -1 != si && (n = ct(n.targetTouches[1]), i += .5 * (n.x - t.x), r += .5 * (n.y - t.y), t = Math.sqrt((t.x - n.x) * (t.x - n.x) + (t.y - n.y) * (t.y - n.y)), k(f.hfov + .1 * (si - t)), si = t);
                t = f.hfov / 360 * f.touchPanSpeedCoeffFactor;
                i = (ei - i) * t + ai;
                h.yaw = (i - f.yaw) % 360 * .2;
                f.yaw = i;
                r = (r - oi) * t + vi;
                h.pitch = .2 * (r - f.pitch);
                f.pitch = r
            }
        }

        function yr() {
            vt = !1;
            150 < Date.now() - p && (h.pitch = h.yaw = 0);
            si = -1;
            p = Date.now();
            nt("touchend", event)
        }

        function su(n) {
            "touch" == n.pointerType && l && f.draggable && (ht.push(n.pointerId), wt.push({
                clientX: n.clientX,
                clientY: n.clientY
            }), n.targetTouches = wt, ar(n), n.preventDefault())
        }

        function hu(n) {
            if ("touch" == n.pointerType && f.draggable)
                for (var t = 0; t < ht.length; t++)
                    if (n.pointerId == ht[t]) {
                        wt[t].clientX = n.clientX;
                        wt[t].clientY = n.clientY;
                        n.targetTouches = wt;
                        vr(n);
                        n.preventDefault();
                        break
                    }
        }

        function pr(n) {
            if ("touch" == n.pointerType) {
                for (var r = !1, t = 0; t < ht.length; t++) n.pointerId == ht[t] && (ht[t] = i), ht[t] && (r = !0);
                r || (ht = [], wt = [], yr());
                n.preventDefault()
            }
        }

        function wr(n) {
            l && ("fullscreenonly" != f.mouseZoom || kt) && (n.preventDefault(), ui(), p = Date.now(), n.wheelDeltaY ? (k(f.hfov - .05 * n.wheelDeltaY), h.hfov = 0 > n.wheelDelta ? 1 : -1) : n.wheelDelta ? (k(f.hfov - .05 * n.wheelDelta), h.hfov = 0 > n.wheelDelta ? 1 : -1) : n.detail && (k(f.hfov + 1.5 * n.detail), h.hfov = 0 < n.detail ? 1 : -1), v())
        }

        function br(n) {
            ui();
            p = Date.now();
            fi();
            f.roll = 0;
            var t = n.which || n.keycode;
            0 > f.capturedKeyNumbers.indexOf(t) || (n.preventDefault(), 27 == t ? kt && rr() : gr(t, !0))
        }

        function kr() {
            for (var n = 0; 10 > n; n++) o[n] = !1
        }

        function dr(n) {
            var t = n.which || n.keycode;
            0 > f.capturedKeyNumbers.indexOf(t) || (n.preventDefault(), gr(t, !1))
        }

        function gr(n, t) {
            var i = !1;
            switch (n) {
                case 109:
                case 189:
                case 17:
                case 173:
                    o[0] != t && (i = !0);
                    o[0] = t;
                    break;
                case 107:
                case 187:
                case 16:
                case 61:
                    o[1] != t && (i = !0);
                    o[1] = t;
                    break;
                case 38:
                    o[2] != t && (i = !0);
                    o[2] = t;
                    break;
                case 87:
                    o[6] != t && (i = !0);
                    o[6] = t;
                    break;
                case 40:
                    o[3] != t && (i = !0);
                    o[3] = t;
                    break;
                case 83:
                    o[7] != t && (i = !0);
                    o[7] = t;
                    break;
                case 37:
                    o[4] != t && (i = !0);
                    o[4] = t;
                    break;
                case 65:
                    o[8] != t && (i = !0);
                    o[8] = t;
                    break;
                case 39:
                    o[5] != t && (i = !0);
                    o[5] = t;
                    break;
                case 68:
                    o[9] != t && (i = !0);
                    o[9] = t
            }
            i && t && (rt = "undefined" != typeof performance && performance.now() ? performance.now() : Date.now(), v())
        }

        function cu() {
            var n;
            if (l) {
                var t = !1,
                    r = f.pitch,
                    e = f.yaw,
                    s = f.hfov,
                    u;
                if (u = "undefined" != typeof performance && performance.now() ? performance.now() : Date.now(), rt === i && (rt = u), n = (u - rt) * f.hfov / 1700, n = Math.min(n, 1), o[0] && !0 === f.keyboardZoom && (k(f.hfov + (.8 * h.hfov + .5) * n), t = !0), o[1] && !0 === f.keyboardZoom && (k(f.hfov + (.8 * h.hfov - .2) * n), t = !0), (o[2] || o[6]) && (f.pitch += (.8 * h.pitch + .2) * n, t = !0), (o[3] || o[7]) && (f.pitch += (.8 * h.pitch - .2) * n, t = !0), (o[4] || o[8]) && (f.yaw += (.8 * h.yaw - .2) * n, t = !0), (o[5] || o[9]) && (f.yaw += (.8 * h.yaw + .2) * n, t = !0), t && (p = Date.now()), f.autoRotate) {
                    if (.001 < u - rt) {
                        var t = (u - rt) / 1e3,
                            c = (h.yaw / t * n - .2 * f.autoRotate) * t,
                            c = (0 < -f.autoRotate ? 1 : -1) * Math.min(Math.abs(f.autoRotate * t), Math.abs(c));
                        f.yaw += c
                    }
                    f.autoRotateStopDelay && (f.autoRotateStopDelay -= u - rt, 0 >= f.autoRotateStopDelay && (f.autoRotateStopDelay = !1, it = f.autoRotate, f.autoRotate = 0))
                }
                w.pitch && (gi("pitch"), r = f.pitch);
                w.yaw && (gi("yaw"), e = f.yaw);
                w.hfov && (gi("hfov"), s = f.hfov);
                0 < n && !f.autoRotate && (t = 1 - f.friction, o[4] || o[5] || o[8] || o[9] || w.yaw || (f.yaw += h.yaw * n * t), o[2] || o[3] || o[6] || o[7] || w.pitch || (f.pitch += h.pitch * n * t), o[0] || o[1] || w.hfov || k(f.hfov + h.hfov * n * t));
                rt = u;
                0 < n && (h.yaw = .8 * h.yaw + (f.yaw - e) / n * .2, h.pitch = .8 * h.pitch + (f.pitch - r) / n * .2, h.hfov = .8 * h.hfov + (f.hfov - s) / n * .2, r = f.autoRotate ? Math.abs(f.autoRotate) : 5, h.yaw = Math.min(r, Math.max(h.yaw, -r)), h.pitch = Math.min(r, Math.max(h.pitch, -r)), h.hfov = Math.min(r, Math.max(h.hfov, -r)));
                o[0] && o[1] && (h.hfov = 0);
                (o[2] || o[6]) && (o[3] || o[7]) && (h.pitch = 0);
                (o[4] || o[8]) && (o[5] || o[9]) && (h.yaw = 0)
            }
        }

        function gi(n) {
            var t = w[n],
                i = Math.min(1, Math.max((Date.now() - t.startTime) / 1e3 / (t.duration / 1e3), 0)),
                i = t.startPosition + f.animationTimingFunction(i) * (t.endPosition - t.startPosition);
            (t.endPosition > t.startPosition && i >= t.endPosition || t.endPosition < t.startPosition && i <= t.endPosition || t.endPosition === t.startPosition) && (i = t.endPosition, h[n] = 0, delete w[n]);
            f[n] = i
        }

        function ii() {
            ot("resize")
        }

        function v() {
            or || (or = !0, ri())
        }

        function ri() {
            if (!uu)
                if (lu(), pi && clearTimeout(pi), vt || !0 === tt) requestAnimationFrame(ri);
                else if (o[0] || o[1] || o[2] || o[3] || o[4] || o[5] || o[6] || o[7] || o[8] || o[9] || f.autoRotate || w.pitch || w.yaw || w.hfov || .01 < Math.abs(h.yaw) || .01 < Math.abs(h.pitch) || .01 < Math.abs(h.hfov)) cu(), 0 <= f.autoRotateInactivityDelay && it && Date.now() - p > f.autoRotateInactivityDelay && !f.autoRotate && (f.autoRotate = it, st.lookAt(hi, i, pt, 3e3)), requestAnimationFrame(ri);
            else if (c && (c.isLoading() || !0 === f.dynamic && wi)) requestAnimationFrame(ri);
            else {
                nt("animatefinished", {
                    pitch: st.getPitch(),
                    yaw: st.getYaw(),
                    hfov: st.getHfov()
                });
                or = !1;
                rt = i;
                var n = f.autoRotateInactivityDelay - (Date.now() - p);
                0 < n ? pi = setTimeout(function() {
                    f.autoRotate = it;
                    st.lookAt(hi, i, pt, 3e3);
                    v()
                }, n) : 0 <= f.autoRotateInactivityDelay && it && (f.autoRotate = it, st.lookAt(hi, i, pt, 3e3), v())
            }
        }

        function lu() {
            var e, n, t, r, u;
            if (l) {
                n = c.getCanvas();
                !1 !== f.autoRotate && (360 < f.yaw ? f.yaw -= 360 : -360 > f.yaw && (f.yaw += 360));
                e = f.yaw;
                t = 0;
                f.avoidShowingBackground && (r = f.hfov / 2, u = 180 * Math.atan2(Math.tan(r / 180 * Math.PI), n.width / n.height) / Math.PI, f.vaov > f.haov ? Math.min(Math.cos((f.pitch - r) / 180 * Math.PI), Math.cos((f.pitch + r) / 180 * Math.PI)) : t = r * (1 - Math.min(Math.cos((f.pitch - u) / 180 * Math.PI), Math.cos((f.pitch + u) / 180 * Math.PI))));
                var r = f.maxYaw - f.minYaw,
                    u = -180,
                    o = 180;
                360 > r && (u = f.minYaw + f.hfov / 2 + t, o = f.maxYaw - f.hfov / 2 - t, r < f.hfov && (u = o = (u + o) / 2), f.yaw = Math.max(u, Math.min(o, f.yaw)));
                !1 === f.autoRotate && (360 < f.yaw ? f.yaw -= 360 : -360 > f.yaw && (f.yaw += 360));
                !1 !== f.autoRotate && e != f.yaw && rt !== i && (f.autoRotate *= -1);
                e = 2 * Math.atan(Math.tan(f.hfov / 180 * Math.PI * .5) / (n.width / n.height)) / Math.PI * 180;
                n = f.minPitch + e / 2;
                t = f.maxPitch - e / 2;
                f.maxPitch - f.minPitch < e && (n = t = (n + t) / 2);
                isNaN(n) && (n = -90);
                isNaN(t) && (t = 90);
                f.pitch = Math.max(n, Math.min(t, f.pitch));
                c.render(f.pitch * Math.PI / 180, f.yaw * Math.PI / 180, f.hfov * Math.PI / 180, {
                    roll: f.roll * Math.PI / 180
                });
                f.hotSpots.forEach(tr);
                f.compass && (dt.style.transform = "rotate(" + (-f.yaw - f.northOffset) + "deg)", dt.style.webkitTransform = "rotate(" + (-f.yaw - f.northOffset) + "deg)")
            }
        }

        function bt(n, t, i, r) {
            this.w = n;
            this.x = t;
            this.y = i;
            this.z = r
        }

        function nr(t) {
            var r, i;
            r = t.alpha;
            i = t.beta;
            t = t.gamma;
            i = [i ? i * Math.PI / 360 : 0, t ? t * Math.PI / 360 : 0, r ? r * Math.PI / 360 : 0];
            r = [Math.cos(i[0]), Math.cos(i[1]), Math.cos(i[2])];
            i = [Math.sin(i[0]), Math.sin(i[1]), Math.sin(i[2])];
            r = new bt(r[0] * r[1] * r[2] - i[0] * i[1] * i[2], i[0] * r[1] * r[2] - r[0] * i[1] * i[2], r[0] * i[1] * r[2] + i[0] * r[1] * i[2], r[0] * r[1] * i[2] + i[0] * i[1] * r[2]);
            r = r.multiply(new bt(Math.sqrt(.5), -Math.sqrt(.5), 0, 0));
            i = n.orientation ? -n.orientation * Math.PI / 360 : 0;
            r = r.multiply(new bt(Math.cos(i), 0, -Math.sin(i), 0)).toEulerAngles();
            "number" == typeof tt && 10 > tt ? tt += 1 : 10 === tt ? (ru = r[2] / Math.PI * 180 + f.yaw, tt = !0, requestAnimationFrame(ri)) : (f.pitch = r[0] / Math.PI * 180, f.roll = -r[1] / Math.PI * 180, f.yaw = -r[2] / Math.PI * 180 + ru)
        }

        function au() {
            try {
                var t = {};
                f.horizonPitch !== i && (t.horizonPitch = f.horizonPitch * Math.PI / 180);
                f.horizonRoll !== i && (t.horizonRoll = f.horizonRoll * Math.PI / 180);
                f.backgroundColor !== i && (t.backgroundColor = f.backgroundColor);
                c.init(b, f.type, f.dynamic, f.haov * Math.PI / 180, f.vaov * Math.PI / 180, f.vOffset * Math.PI / 180, vu, t);
                !0 !== f.dynamic && (b = i)
            } catch (n) {
                if ("webgl error" == n.type || "no webgl" == n.type) et();
                else if ("webgl size error" == n.type) et(f.strings.textureSizeError.replace("%s", n.width).replace("%s", n.maxWidth));
                else throw et(f.strings.unknownError), n;
            }
        }

        function vu() {
            if (f.sceneFadeDuration && c.fadeImg !== i) {
                c.fadeImg.style.opacity = 0;
                var n = c.fadeImg;
                delete c.fadeImg;
                setTimeout(function() {
                    y.removeChild(n);
                    nt("scenechangefadedone")
                }, f.sceneFadeDuration)
            }
            dt.style.display = f.compass ? "inline" : "none";
            yu();
            e.load.box.style.display = "none";
            yt !== i && (y.removeChild(yt), yt = i);
            l = !0;
            nt("load");
            v()
        }

        function nu(n) {
            var i, u, r, e, o;
            if (n.pitch = Number(n.pitch) || 0, n.yaw = Number(n.yaw) || 0, i = t.createElement("div"), i.className = "pnlm-hotspot-base", i.className = n.cssClass ? i.className + (" " + n.cssClass) : i.className + (" pnlm-hotspot pnlm-sprite pnlm-" + lt(n.type)), u = t.createElement("span"), n.text && (u.innerHTML = lt(n.text)), n.video) r = t.createElement("video"), e = n.video, f.basePath && !gt(e) && (e = f.basePath + e), r.src = at(e), r.controls = !0, r.style.width = n.width + "px", y.appendChild(i), u.appendChild(r);
            else if (n.image) e = n.image, f.basePath && !gt(e) && (e = f.basePath + e), r = t.createElement("a"), r.href = at(n.URL ? n.URL : e, !0), r.target = "_blank", u.appendChild(r), o = t.createElement("img"), o.src = at(e), o.style.width = n.width + "px", o.style.paddingTop = "5px", y.appendChild(i), r.appendChild(o), u.style.maxWidth = "initial";
            else if (n.URL) {
                if (r = t.createElement("a"), r.href = at(n.URL, !0), n.attributes)
                    for (e in n.attributes) r.setAttribute(e, n.attributes[e]);
                else r.target = "_blank";
                y.appendChild(r);
                i.className += " pnlm-pointer";
                u.className += " pnlm-pointer";
                r.appendChild(i)
            } else n.sceneId && (i.onclick = i.ontouchend = function() {
                return i.clicked || (i.clicked = !0, ur(n.sceneId, n.targetPitch, n.targetYaw, n.targetHfov)), !1
            }, i.className += " pnlm-pointer", u.className += " pnlm-pointer"), y.appendChild(i);
            n.createTooltipFunc ? n.createTooltipFunc(i, n.createTooltipArgs) : (n.text || n.video || n.image) && (i.classList.add("pnlm-tooltip"), i.appendChild(u), u.style.width = u.scrollWidth - 20 + "px", u.style.marginLeft = -(u.scrollWidth - i.offsetWidth) / 2 + "px", u.style.marginTop = -u.scrollHeight - 12 + "px");
            n.clickHandlerFunc && (i.addEventListener("click", function(t) {
                n.clickHandlerFunc(t, n.clickHandlerArgs)
            }, "false"), i.className += " pnlm-pointer", u.className += " pnlm-pointer");
            n.div = i
        }

        function yu() {
            sr || (f.hotSpots ? (f.hotSpots = f.hotSpots.sort(function(n, t) {
                return n.pitch < t.pitch
            }), f.hotSpots.forEach(nu)) : f.hotSpots = [], sr = !0, f.hotSpots.forEach(tr))
        }

        function pu() {
            var i = f.hotSpots,
                t, n;
            if (sr = !1, delete f.hotSpots, i)
                for (t = 0; t < i.length; t++) {
                    if (n = i[t].div, n) {
                        for (; n.parentNode && n.parentNode != y;) n = n.parentNode;
                        y.removeChild(n)
                    }
                    delete i[t].div
                }
        }

        function tr(n) {
            var t = Math.sin(n.pitch * Math.PI / 180),
                r = Math.cos(n.pitch * Math.PI / 180),
                e = Math.sin(f.pitch * Math.PI / 180),
                h = Math.cos(f.pitch * Math.PI / 180),
                l = Math.cos((-n.yaw + f.yaw) * Math.PI / 180),
                u = t * e + r * l * h,
                a, o;
            if (90 >= n.yaw && -90 < n.yaw && 0 >= u || (90 < n.yaw || -90 >= n.yaw) && 0 >= u) n.div.style.visibility = "hidden";
            else {
                a = Math.sin((-n.yaw + f.yaw) * Math.PI / 180);
                o = Math.tan(f.hfov * Math.PI / 360);
                n.div.style.visibility = "visible";
                var s = c.getCanvas(),
                    i = s.clientWidth,
                    s = s.clientHeight,
                    t = [-i / o * a * r / u / 2, -i / o * (t * h - r * l * e) / u / 2],
                    r = Math.sin(f.roll * Math.PI / 180),
                    e = Math.cos(f.roll * Math.PI / 180),
                    t = [t[0] * e - t[1] * r, t[0] * r + t[1] * e];
                t[0] += (i - n.div.offsetWidth) / 2;
                t[1] += (s - n.div.offsetHeight) / 2;
                i = "translate(" + t[0] + "px, " + t[1] + "px) translateZ(9999px) rotate(" + f.roll + "deg)";
                n.scale && (i += " scale(" + pt / f.hfov / u + ")");
                n.div.style.webkitTransform = i;
                n.div.style.MozTransform = i;
                n.div.style.transform = i
            }
        }

        function li(n) {
            var t, i, e, r;
            f = {};
            e = "haov vaov vOffset northOffset horizonPitch horizonRoll".split(" ");
            ut = [];
            for (t in hr) hr.hasOwnProperty(t) && (f[t] = hr[t]);
            for (t in u.default)
                if (u.default.hasOwnProperty(t))
                    if ("strings" == t)
                        for (i in u.default.strings) u.default.strings.hasOwnProperty(i) && (f.strings[i] = lt(u.default.strings[i]));
                    else f[t] = u.default[t], 0 <= e.indexOf(t) && ut.push(t);
            if (null !== n && "" !== n && u.scenes && u.scenes[n]) {
                r = u.scenes[n];
                for (t in r)
                    if (r.hasOwnProperty(t))
                        if ("strings" == t)
                            for (i in r.strings) r.strings.hasOwnProperty(i) && (f.strings[i] = lt(r.strings[i]));
                        else f[t] = r[t], 0 <= e.indexOf(t) && ut.push(t);
                f.scene = n
            }
            for (t in u)
                if (u.hasOwnProperty(t))
                    if ("strings" == t)
                        for (i in u.strings) u.strings.hasOwnProperty(i) && (f.strings[i] = lt(u.strings[i]));
                    else f[t] = u[t], 0 <= e.indexOf(t) && ut.push(t)
        }

        function ir(n) {
            var o, l, r, u, h;
            (n = n ? n : !1) && "preview" in f && (o = f.preview, f.basePath && !gt(o) && (o = f.basePath + o), yt = t.createElement("div"), yt.className = "pnlm-preview-img", yt.style.backgroundImage = "url('" + at(o).replace(/"/g, "%22").replace(/'/g, "%27") + "')", y.appendChild(yt));
            o = f.title;
            l = f.author;
            n && ("previewTitle" in f && (f.title = f.previewTitle), "previewAuthor" in f && (f.author = f.previewAuthor));
            f.hasOwnProperty("title") || (e.title.innerHTML = "");
            f.hasOwnProperty("author") || (e.author.innerHTML = "");
            f.hasOwnProperty("title") || f.hasOwnProperty("author") || (e.container.style.display = "none");
            s.load.innerHTML = "<p>" + f.strings.loadButtonLabel + "<\/p>";
            e.load.boxp.innerHTML = f.strings.loadingLabel;
            for (r in f)
                if (f.hasOwnProperty(r)) switch (r) {
                    case "title":
                        e.title.innerHTML = lt(f[r]);
                        e.container.style.display = "inline";
                        break;
                    case "author":
                        u = lt(f[r]);
                        f.authorURL && (u = t.createElement("a"), u.href = at(f.authorURL, !0), u.target = "_blank", u.innerHTML = lt(f[r]), u = u.outerHTML);
                        e.author.innerHTML = f.strings.bylineLabel.replace("%s", u);
                        e.container.style.display = "inline";
                        break;
                    case "fallback":
                        u = t.createElement("a");
                        u.href = at(f[r], !0);
                        u.target = "_blank";
                        u.textContent = "Click here to view this panorama in an alternative viewer.";
                        h = t.createElement("p");
                        h.textContent = "Your browser does not support WebGL.";
                        h.appendChild(t.createElement("br"));
                        h.appendChild(u);
                        e.errorMsg.innerHTML = "";
                        e.errorMsg.appendChild(h);
                        break;
                    case "hfov":
                        k(Number(f[r]));
                        break;
                    case "autoLoad":
                        !0 === f[r] && c === i && (e.load.box.style.display = "inline", s.load.style.display = "none", cr());
                        break;
                    case "showZoomCtrl":
                        s.zoom.style.display = f[r] && !1 != f.showControls ? "block" : "none";
                        break;
                    case "showFullscreenCtrl":
                        s.fullscreen.style.display = f[r] && !1 != f.showControls && ("fullscreen" in t || "mozFullScreen" in t || "webkitIsFullScreen" in t || "msFullscreenElement" in t) ? "block" : "none";
                        break;
                    case "hotSpotDebug":
                        bi.style.display = f[r] ? "block" : "none";
                        break;
                    case "showControls":
                        f[r] || (s.orientation.style.display = "none", s.zoom.style.display = "none", s.fullscreen.style.display = "none");
                        break;
                    case "orientationOnByDefault":
                        f[r] && fr()
                }
            n && (o ? f.title = o : delete f.title, l ? f.author = l : delete f.author)
        }

        function rr() {
            if (l && !yi)
                if (kt) t.exitFullscreen ? t.exitFullscreen() : t.mozCancelFullScreen ? t.mozCancelFullScreen() : t.webkitCancelFullScreen ? t.webkitCancelFullScreen() : t.msExitFullscreen && t.msExitFullscreen();
                else try {
                    r.requestFullscreen ? r.requestFullscreen() : r.mozRequestFullScreen ? r.mozRequestFullScreen() : r.msRequestFullscreen ? r.msRequestFullscreen() : r.webkitRequestFullScreen()
                } catch (n) {}
        }

        function ot(n) {
            t.fullscreenElement || t.fullscreen || t.mozFullScreen || t.webkitIsFullScreen || t.msFullscreenElement ? (s.fullscreen.classList.add("pnlm-fullscreen-toggle-button-active"), kt = !0) : (s.fullscreen.classList.remove("pnlm-fullscreen-toggle-button-active"), kt = !1);
            "resize" !== n && nt("fullscreenchange", kt);
            c.resize();
            k(f.hfov);
            v()
        }

        function tu(n) {
            var t = f.minHfov,
                i;
            return ("multires" == f.type && c && !f.multiResMinHfov && (t = Math.min(t, c.getCanvas().width / (f.multiRes.cubeResolution / 90 * .9))), t > f.maxHfov) ? (console.log("HFOV bounds do not make sense (minHfov > maxHfov)."), f.hfov) : (i = f.hfov, i = n < t ? t : n > f.maxHfov ? f.maxHfov : n, f.avoidShowingBackground && c && (n = c.getCanvas(), i = Math.min(i, 360 * Math.atan(Math.tan((f.maxPitch - f.minPitch) / 360 * Math.PI) / n.height * n.width) / Math.PI)), i)
        }

        function k(n) {
            f.hfov = tu(n);
            nt("zoomchange", f.hfov)
        }

        function ui() {
            w = {};
            it = f.autoRotate ? f.autoRotate : it;
            f.autoRotate = !1
        }

        function iu() {
            yi && (e.load.box.style.display = "none", e.errorMsg.style.display = "none", yi = !1, y.style.display = "block", nt("errorcleared"));
            l = !1;
            s.load.style.display = "none";
            e.load.box.style.display = "inline";
            cr()
        }

        function ur(n, t, r, e, o) {
            l || (o = !0);
            l = !1;
            w = {};
            var s, a;
            if (f.sceneFadeDuration && !o && (s = c.render(f.pitch * Math.PI / 180, f.yaw * Math.PI / 180, f.hfov * Math.PI / 180, {
                    returnImage: !0
                }), s !== i)) {
                o = new Image;
                o.className = "pnlm-fade-img";
                o.style.transition = "opacity " + f.sceneFadeDuration / 1e3 + "s";
                o.style.width = "100%";
                o.style.height = "100%";
                o.onload = function() {
                    ur(n, t, r, e, !0)
                };
                o.src = s;
                y.appendChild(o);
                c.fadeImg = o;
                return
            }
            o = "same" === t ? f.pitch : t;
            s = "same" === r ? f.yaw : "sameAzimuth" === r ? f.yaw + (f.northOffset || 0) - (u.scenes[n].northOffset || 0) : r;
            a = "same" === e ? f.hfov : e;
            pu();
            li(n);
            h.yaw = h.pitch = h.hfov = 0;
            ir();
            o !== i && (f.pitch = o);
            s !== i && (f.yaw = s);
            a !== i && (f.hfov = a);
            nt("scenechange", n);
            iu()
        }

        function fi() {
            n.removeEventListener("deviceorientation", nr);
            s.orientation.classList.remove("pnlm-orientation-button-active");
            tt = !1
        }

        function fr() {
            "function" == typeof DeviceMotionEvent.requestPermission ? DeviceOrientationEvent.requestPermission().then(function(t) {
                "granted" == t && (tt = 1, n.addEventListener("deviceorientation", nr), s.orientation.classList.add("pnlm-orientation-button-active"))
            }) : (tt = 1, n.addEventListener("deviceorientation", nr), s.orientation.classList.add("pnlm-orientation-button-active"))
        }

        function lt(n) {
            return u.escapeHTML ? String(n).split(/&/g).join("&amp;").split('"').join("&quot;").split("'").join("&#39;").split("<").join("&lt;").split(">").join("&gt;").split("/").join("&#x2f;").split("\n").join("<br>") : String(n).split("\n").join("<br>")
        }

        function at(n, t) {
            try {
                var i = decodeURIComponent(wu(n)).replace(/[^\w:]/g, "").toLowerCase()
            } catch (r) {
                return "about:blank"
            }
            return 0 === i.indexOf("javascript:") || 0 === i.indexOf("vbscript:") ? (console.log("Script URL removed."), "about:blank") : t && 0 === i.indexOf("data:") ? (console.log("Data URI removed from link."), "about:blank") : n
        }

        function wu(n) {
            return n.replace(/&(#(?:\d+)|(?:#x[0-9A-Fa-f]+)|(?:\w+));?/ig, function(n, t) {
                return t = t.toLowerCase(), "colon" === t ? ":" : "#" === t.charAt(0) ? "x" === t.charAt(1) ? String.fromCharCode(parseInt(t.substring(2), 16)) : String.fromCharCode(+t.substring(1)) : ""
            })
        }

        function nt(n) {
            if (n in d)
                for (var t = d[n].length; 0 < t; t--) d[n][d[n].length - t].apply(null, [].slice.call(arguments, 1))
        }
        var st = this,
            f, c, yt, vt = !1,
            p = Date.now(),
            ei = 0,
            oi = 0,
            si = -1,
            ai = 0,
            vi = 0,
            o = Array(10),
            kt = !1,
            l, yi = !1,
            er = !1,
            b, rt, h = {
                yaw: 0,
                pitch: 0,
                hfov: 0
            },
            or = !1,
            tt = !1,
            ru = 0,
            pi, it = 0,
            pt, hi, w = {},
            d = {},
            ut = [],
            wi = !1,
            sr = !1,
            uu = !1,
            hr = {
                hfov: 100,
                minHfov: 50,
                multiResMinHfov: !1,
                maxHfov: 120,
                pitch: 0,
                minPitch: i,
                maxPitch: i,
                yaw: 0,
                minYaw: -180,
                maxYaw: 180,
                roll: 0,
                haov: 360,
                vaov: 180,
                vOffset: 0,
                autoRotate: !1,
                autoRotateInactivityDelay: -1,
                autoRotateStopDelay: i,
                type: "equirectangular",
                northOffset: 0,
                showFullscreenCtrl: !0,
                dynamic: !1,
                dynamicUpdate: !1,
                doubleClickZoom: !0,
                keyboardZoom: !0,
                mouseZoom: !0,
                showZoomCtrl: !0,
                autoLoad: !1,
                showControls: !0,
                orientationOnByDefault: !1,
                hotSpotDebug: !1,
                backgroundColor: [0, 0, 0],
                avoidShowingBackground: !1,
                animationTimingFunction: function(n) {
                    return .5 > n ? 2 * n * n : -1 + (4 - 2 * n) * n
                },
                draggable: !0,
                disableKeyboardCtrl: !1,
                crossOrigin: "anonymous",
                touchPanSpeedCoeffFactor: 1,
                capturedKeyNumbers: [16, 17, 27, 37, 38, 39, 40, 61, 65, 68, 83, 87, 107, 109, 173, 187, 189],
                friction: .15,
                strings: {
                    loadButtonLabel: "Click to<br>Load<br>Panorama",
                    loadingLabel: "Loading...",
                    bylineLabel: "by %s",
                    noPanoramaError: "No panorama image was specified.",
                    fileAccessError: "The file %s could not be accessed.",
                    malformedURLError: "There is something wrong with the panorama URL.",
                    iOS8WebGLError: "Due to iOS 8's broken WebGL implementation, only progressive encoded JPEGs work for your device (this panorama uses standard encoding).",
                    genericWebGLError: "Your browser does not have the necessary WebGL support to display this panorama.",
                    textureSizeError: "This panorama is too big for your device! It's %spx wide, but your device only supports images up to %spx wide. Try another device. (If you're the author, try scaling down the image.)",
                    unknownError: "Unknown error. Check developer console."
                }
            },
            a, y, g, ft, e, bi, s, ki, dt, ht, wt;
        r = "string" == typeof r ? t.getElementById(r) : r;
        r.classList.add("pnlm-container");
        r.tabIndex = 0;
        a = t.createElement("div");
        a.className = "pnlm-ui";
        r.appendChild(a);
        y = t.createElement("div");
        y.className = "pnlm-render-container";
        r.appendChild(y);
        g = t.createElement("div");
        g.className = "pnlm-dragfix";
        a.appendChild(g);
        ft = t.createElement("span");
        ft.className = "pnlm-about-msg";
        ft.innerHTML = '<a href="https://pannellum.org/" target="_blank">Pannellum<\/a> 2.5.6';
        a.appendChild(ft);
        g.addEventListener("contextmenu", ti);
        e = {};
        bi = t.createElement("div");
        bi.className = "pnlm-sprite pnlm-hot-spot-debug-indicator";
        a.appendChild(bi);
        e.container = t.createElement("div");
        e.container.className = "pnlm-panorama-info";
        e.title = t.createElement("div");
        e.title.className = "pnlm-title-box";
        e.container.appendChild(e.title);
        e.author = t.createElement("div");
        e.author.className = "pnlm-author-box";
        e.container.appendChild(e.author);
        a.appendChild(e.container);
        e.load = {};
        e.load.box = t.createElement("div");
        e.load.box.className = "pnlm-load-box";
        e.load.boxp = t.createElement("p");
        e.load.box.appendChild(e.load.boxp);
        e.load.lbox = t.createElement("div");
        e.load.lbox.className = "pnlm-lbox";
        e.load.lbox.innerHTML = '<div class="pnlm-loading"><\/div>';
        e.load.box.appendChild(e.load.lbox);
        e.load.lbar = t.createElement("div");
        e.load.lbar.className = "pnlm-lbar";
        e.load.lbarFill = t.createElement("div");
        e.load.lbarFill.className = "pnlm-lbar-fill";
        e.load.lbar.appendChild(e.load.lbarFill);
        e.load.box.appendChild(e.load.lbar);
        e.load.msg = t.createElement("p");
        e.load.msg.className = "pnlm-lmsg";
        e.load.box.appendChild(e.load.msg);
        a.appendChild(e.load.box);
        e.errorMsg = t.createElement("div");
        e.errorMsg.className = "pnlm-error-msg pnlm-info-box";
        a.appendChild(e.errorMsg);
        s = {};
        s.container = t.createElement("div");
        s.container.className = "pnlm-controls-container";
        a.appendChild(s.container);
        s.load = t.createElement("div");
        s.load.className = "pnlm-load-button";
        s.load.addEventListener("click", function() {
            ir();
            iu()
        });
        a.appendChild(s.load);
        s.zoom = t.createElement("div");
        s.zoom.className = "pnlm-zoom-controls pnlm-controls";
        s.zoomIn = t.createElement("div");
        s.zoomIn.className = "pnlm-zoom-in pnlm-sprite pnlm-control";
        s.zoomIn.addEventListener("click", function() {
            l && (k(f.hfov - 5), v())
        });
        s.zoom.appendChild(s.zoomIn);
        s.zoomOut = t.createElement("div");
        s.zoomOut.className = "pnlm-zoom-out pnlm-sprite pnlm-control";
        s.zoomOut.addEventListener("click", function() {
            l && (k(f.hfov + 5), v())
        });
        s.zoom.appendChild(s.zoomOut);
        s.container.appendChild(s.zoom);
        s.fullscreen = t.createElement("div");
        s.fullscreen.addEventListener("click", rr);
        s.fullscreen.className = "pnlm-fullscreen-toggle-button pnlm-sprite pnlm-fullscreen-toggle-button-inactive pnlm-controls pnlm-control";
        (t.fullscreenEnabled || t.mozFullScreenEnabled || t.webkitFullscreenEnabled || t.msFullscreenEnabled) && s.container.appendChild(s.fullscreen);
        s.orientation = t.createElement("div");
        s.orientation.addEventListener("click", function() {
            tt ? fi() : fr()
        });
        s.orientation.addEventListener("mousedown", function(n) {
            n.stopPropagation()
        });
        s.orientation.addEventListener("touchstart", function(n) {
            n.stopPropagation()
        });
        s.orientation.addEventListener("pointerdown", function(n) {
            n.stopPropagation()
        });
        s.orientation.className = "pnlm-orientation-button pnlm-orientation-button-inactive pnlm-sprite pnlm-controls pnlm-control";
        ki = !1;
        n.DeviceOrientationEvent && "https:" == location.protocol && 0 <= navigator.userAgent.toLowerCase().indexOf("mobi") && (s.container.appendChild(s.orientation), ki = !0);
        dt = t.createElement("div");
        dt.className = "pnlm-compass pnlm-controls pnlm-control";
        a.appendChild(dt);
        u.firstScene ? li(u.firstScene) : u.default && u.default.firstScene ? li(u.default.firstScene) : li(null);
        ir(!0);
        ht = [];
        wt = [];
        bt.prototype.multiply = function(n) {
            return new bt(this.w * n.w - this.x * n.x - this.y * n.y - this.z * n.z, this.x * n.w + this.w * n.x + this.y * n.z - this.z * n.y, this.y * n.w + this.w * n.y + this.z * n.x - this.x * n.z, this.z * n.w + this.w * n.z + this.x * n.y - this.y * n.x)
        };
        bt.prototype.toEulerAngles = function() {
            var n = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y)),
                t = Math.asin(2 * (this.w * this.y - this.z * this.x)),
                i = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
            return [n, t, i]
        };
        this.isLoaded = function() {
            return Boolean(l)
        };
        this.getPitch = function() {
            return f.pitch
        };
        this.setPitch = function(n, t, r, u) {
            return (p = Date.now(), 1e-6 >= Math.abs(n - f.pitch)) ? ("function" == typeof r && r(u), this) : ((t = t == i ? 1e3 : Number(t)) ? (w.pitch = {
                startTime: Date.now(),
                startPosition: f.pitch,
                endPosition: n,
                duration: t
            }, "function" == typeof r && setTimeout(function() {
                r(u)
            }, t)) : f.pitch = n, v(), this)
        };
        this.getPitchBounds = function() {
            return [f.minPitch, f.maxPitch]
        };
        this.setPitchBounds = function(n) {
            return f.minPitch = Math.max(-90, Math.min(n[0], 90)), f.maxPitch = Math.max(-90, Math.min(n[1], 90)), this
        };
        this.getYaw = function() {
            return (f.yaw + 540) % 360 - 180
        };
        this.setYaw = function(n, t, r, u) {
            return (p = Date.now(), 1e-6 >= Math.abs(n - f.yaw)) ? ("function" == typeof r && r(u), this) : (t = t == i ? 1e3 : Number(t), n = (n + 180) % 360 - 180, t ? (180 < f.yaw - n ? n += 360 : 180 < n - f.yaw && (n -= 360), w.yaw = {
                startTime: Date.now(),
                startPosition: f.yaw,
                endPosition: n,
                duration: t
            }, "function" == typeof r && setTimeout(function() {
                r(u)
            }, t)) : f.yaw = n, v(), this)
        };
        this.getYawBounds = function() {
            return [f.minYaw, f.maxYaw]
        };
        this.setYawBounds = function(n) {
            return f.minYaw = Math.max(-360, Math.min(n[0], 360)), f.maxYaw = Math.max(-360, Math.min(n[1], 360)), this
        };
        this.getHfov = function() {
            return f.hfov
        };
        this.setHfov = function(n, t, r, u) {
            return (p = Date.now(), 1e-6 >= Math.abs(n - f.hfov)) ? ("function" == typeof r && r(u), this) : ((t = t == i ? 1e3 : Number(t)) ? (w.hfov = {
                startTime: Date.now(),
                startPosition: f.hfov,
                endPosition: tu(n),
                duration: t
            }, "function" == typeof r && setTimeout(function() {
                r(u)
            }, t)) : k(n), v(), this)
        };
        this.getHfovBounds = function() {
            return [f.minHfov, f.maxHfov]
        };
        this.setHfovBounds = function(n) {
            return f.minHfov = Math.max(0, n[0]), f.maxHfov = Math.max(0, n[1]), this
        };
        this.lookAt = function(n, t, r, u, e, o) {
            return u = u == i ? 1e3 : Number(u), n !== i && 1e-6 < Math.abs(n - f.pitch) && (this.setPitch(n, u, e, o), e = i), t !== i && 1e-6 < Math.abs(t - f.yaw) && (this.setYaw(t, u, e, o), e = i), r !== i && 1e-6 < Math.abs(r - f.hfov) && (this.setHfov(r, u, e, o), e = i), "function" == typeof e && e(o), this
        };
        this.getNorthOffset = function() {
            return f.northOffset
        };
        this.setNorthOffset = function(n) {
            return f.northOffset = Math.min(360, Math.max(0, n)), v(), this
        };
        this.getHorizonRoll = function() {
            return f.horizonRoll
        };
        this.setHorizonRoll = function(n) {
            return f.horizonRoll = Math.min(90, Math.max(-90, n)), c.setPose(f.horizonPitch * Math.PI / 180, f.horizonRoll * Math.PI / 180), v(), this
        };
        this.getHorizonPitch = function() {
            return f.horizonPitch
        };
        this.setHorizonPitch = function(n) {
            return f.horizonPitch = Math.min(90, Math.max(-90, n)), c.setPose(f.horizonPitch * Math.PI / 180, f.horizonRoll * Math.PI / 180), v(), this
        };
        this.startAutoRotate = function(n, t) {
            return n = n || it || 1, t = t === i ? hi : t, f.autoRotate = n, st.lookAt(t, i, pt, 3e3), v(), this
        };
        this.stopAutoRotate = function() {
            return it = f.autoRotate ? f.autoRotate : it, f.autoRotate = !1, f.autoRotateInactivityDelay = -1, this
        };
        this.stopMovement = function() {
            ui();
            h = {
                yaw: 0,
                pitch: 0,
                hfov: 0
            }
        };
        this.getRenderer = function() {
            return c
        };
        this.setUpdate = function(n) {
            return wi = !0 === n, c === i ? ni() : v(), this
        };
        this.mouseEventToCoords = function(n) {
            return di(n)
        };
        this.loadScene = function(n, t, i, r) {
            return !1 !== l && ur(n, t, i, r), this
        };
        this.getScene = function() {
            return f.scene
        };
        this.addScene = function(n, t) {
            return u.scenes[n] = t, this
        };
        this.removeScene = function(n) {
            return f.scene === n || !u.scenes.hasOwnProperty(n) ? !1 : (delete u.scenes[n], !0)
        };
        this.toggleFullscreen = function() {
            return rr(), this
        };
        this.getConfig = function() {
            return f
        };
        this.getContainer = function() {
            return r
        };
        this.addHotSpot = function(n, t) {
            if (t === i && f.scene === i) f.hotSpots.push(n);
            else {
                var r = t !== i ? t : f.scene;
                if (u.scenes.hasOwnProperty(r)) u.scenes[r].hasOwnProperty("hotSpots") || (u.scenes[r].hotSpots = [], r == f.scene && (f.hotSpots = u.scenes[r].hotSpots)), u.scenes[r].hotSpots.push(n);
                else throw "Invalid scene ID!";
            }
            return (t === i || f.scene == t) && (nu(n), l && tr(n)), this
        };
        this.removeHotSpot = function(n, t) {
            var r, e;
            if (t === i || f.scene == t) {
                if (!f.hotSpots) return !1;
                for (r = 0; r < f.hotSpots.length; r++)
                    if (f.hotSpots[r].hasOwnProperty("id") && f.hotSpots[r].id === n) {
                        for (e = f.hotSpots[r].div; e.parentNode != y;) e = e.parentNode;
                        return y.removeChild(e), delete f.hotSpots[r].div, f.hotSpots.splice(r, 1), !0
                    }
            } else if (u.scenes.hasOwnProperty(t)) {
                if (!u.scenes[t].hasOwnProperty("hotSpots")) return !1;
                for (r = 0; r < u.scenes[t].hotSpots.length; r++)
                    if (u.scenes[t].hotSpots[r].hasOwnProperty("id") && u.scenes[t].hotSpots[r].id === n) return u.scenes[t].hotSpots.splice(r, 1), !0
            } else return !1
        };
        this.resize = function() {
            c && ii()
        };
        this.isLoaded = function() {
            return l
        };
        this.isOrientationSupported = function() {
            return ki || !1
        };
        this.stopOrientation = function() {
            fi()
        };
        this.startOrientation = function() {
            ki && fr()
        };
        this.isOrientationActive = function() {
            return Boolean(tt)
        };
        this.on = function(n, t) {
            return d[n] = d[n] || [], d[n].push(t), this
        };
        this.off = function(n, t) {
            if (!n) return d = {}, this;
            if (t) {
                var i = d[n].indexOf(t);
                0 <= i && d[n].splice(i, 1);
                0 == d[n].length && delete d[n]
            } else delete d[n];
            return this
        };
        this.destroy = function() {
            uu = !0;
            clearTimeout(pi);
            c && c.destroy();
            er && (t.removeEventListener("mousemove", lr, !1), t.removeEventListener("mouseup", ci, !1), r.removeEventListener("mozfullscreenchange", ot, !1), r.removeEventListener("webkitfullscreenchange", ot, !1), r.removeEventListener("msfullscreenchange", ot, !1), r.removeEventListener("fullscreenchange", ot, !1), n.removeEventListener("resize", ii, !1), n.removeEventListener("orientationchange", ii, !1), r.removeEventListener("keydown", br, !1), r.removeEventListener("keyup", dr, !1), r.removeEventListener("blur", kr, !1), t.removeEventListener("mouseleave", ci, !1));
            r.innerHTML = "";
            r.classList.remove("pnlm-container")
        }
    }
    return {
        viewer: function(n, t) {
            return new r(n, t)
        }
    }
}(window, document);